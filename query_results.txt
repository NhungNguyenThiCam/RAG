Nội dung: in general constitutes a major use of Java. The Java Buzzwords No discussion of Java’s history is complete without a look at the Java buzzwords. Although the fundamental forces that necessitated the invention of Java are portability and security, other factors also played an important role in molding the final form of the language. The key considerations were summed up by the Java team in the following list of buzzwords: • Simple • Secure • Portable • Object-oriented • Robust • Multithreaded • Architecture-neutral • Interpreted • High performance • Distributed • Dynamic Two of these buzzwords have already been discussed: secure and portable. Let’s examine what each of the others implies. Simple Java was designed to be easy for the professional programmer to learn and use effectively. Assuming that you have some programming experience, you will not find Java hard to master. If you already understand the basic concepts of object-oriented programming, learning Java will be even easier. Best of all, if you are an experienced C++ programmer, moving to Java will require very little effort. Because Java inherits the C/C++ syntax and many of the object- oriented features of C++, most programmers have little trouble learning Java. Object-Oriented Although influenced by its predecessors, Java was not designed to be source- code compatible with any other language. This allowed the Java team the freedom to design with a blank slate. One outcome of this was a clean, usable, pragmatic approach to objects. Borrowing liberally from many seminal object- software environments of the last few decades, Java manages to strike a balance between the purist’s “everything is an object” paradigm and the pragmatist’s “stay out of my way” model. The object model in Java is simple and easy to extend, while primitive types, such as integers, are kept as high- performance nonobjects. Robust performance nonobjects. Robust The multiplatformed environment of the Web places extraordinary demands on a program, because the program must execute reliably in a variety of systems. Thus, the ability to create robust programs was given a high priority in the design of Java. To gain reliability, Java restricts you in a few key areas to force you to find your mistakes early in program development. At the same time, Java frees you from having to worry about many of the most common causes of Java frees you from having to worry about many of the most common causes of programming errors. Because Java is a strictly typed language, it checks your code at compile time. However, it also checks your code at run time. Many hard-to-track-down bugs that often turn up in hard-to-reproduce run-time situations are simply impossible to create in Java. Knowing that what you have written will behave in a predictable way under diverse conditions is a key feature of Java. feature of Java. To better understand how Java is robust, consider two of the main reasons for program failure: memory management mistakes and mishandled exceptional conditions (that is, run-time errors). Memory management can be a difficult, tedious task in traditional programming environments. For example, in C/C++, the programmer will often manually allocate and free dynamic memory. This sometimes leads to problems, because programmers will either forget to free memory that has been previously allocated or, worse, try to free some memory that another part of their code is still using. Java virtually eliminates these problems by managing memory allocation and deallocation for you. (In fact, deallocation is completely automatic, because Java provides garbage collection for unused objects.) Exceptional conditions in traditional environments often arise in situations such as division by zero or “file not found,” and they must be managed with clumsy and hard-to-read constructs. Java helps in this area by providing object-oriented exception handling. In a well-written Java program, all run-time errors can—and should—be managed by your program. Multithreaded Java was designed to meet the real-world requirement of creating interactive, networked programs. To accomplish this, Java supports multithreaded programming, which allows you to write programs that do many things simultaneously. The Java run-time system comes with an elegant yet sophisticated solution for multiprocess synchronization that enables you to construct smoothly running interactive systems. Java’s easy-to-use approach to multithreading allows you to think about the specific behavior of your program, not the multitasking subsystem. Architecture-Neutral A central issue for the Java designers was that of code longevity and portability. At the time of Java’s creation, one of the main problems facing programmers was that no guarantee existed that if you wrote a program today, it would run tomorrow—even on the same machine. Operating system it would run tomorrow—even on the same machine. Operating system upgrades, processor upgrades, and changes in core system resources can all combine to make a program malfunction. The Java designers made several hard decisions in the Java language and the Java Virtual Machine in an attempt to alter this situation. Their goal was “write once; run anywhere, any time, forever.” To a great extent, this goal was accomplished. Interpreted and High Performance Interpreted and High Performance As described earlier, Java enables the creation of cross-platform programs by compiling into an intermediate representation called Java bytecode. This code can be executed on any system that implements the Java Virtual Machine. Most previous attempts at cross-platform solutions have done so at the expense of performance. As explained earlier, the Java bytecode was carefully designed so that it would be easy to translate directly into native machine code for very high performance by using a just-in-time compiler. Java run-time systems that provide this feature lose none of the benefits of the platform-independent code. Distributed Java is designed for the distributed environment of the Internet because it handles TCP/IP protocols. In fact, accessing a resource using a URL is not much different from accessing a file. Java also supports Remote Method Invocation (RMI) . This feature enables a program to invoke methods across a network. Dynamic network. Dynamic Java programs carry with them substantial amounts of run-time type information that is used to verify and resolve accesses to objects at run time. This makes it possible to dynamically link code in a safe and expedient manner. This is crucial to the robustness of the Java environment, in which small fragments of bytecode may be dynamically updated on a running system. The Evolution of Java The initial release of Java was nothing short of revolutionary, but it did not mark the end of Java’s era of rapid innovation. Unlike most other software systems that usually settle into a pattern of small, incremental improvements, Java continued to evolve at an explosive pace. Soon after the release of Java Java continued to evolve at an explosive pace. Soon after the release of Java 1.0, the designers of Java had already created Java 1.1. The features added by Java 1.1 were more significant and substantial than the increase in the minor revision number would have you think. Java 1.1 added many new library elements, redefined the way events are handled, and reconfigured many features of the 1.0 library. It also deprecated (rendered obsolete) several features originally defined by Java 1.0. Thus, Java 1.1 both added to and subtracted from attributes of its original specification. The next major release of Java was Java 2, where the “2” indicates “second generation.” The creation of Java 2 was a watershed event, marking the beginning of Java’s “modern age.” The first release of Java 2 carried the version number 1.2. It may seem odd that the first release of Java 2 used the 1.2 version number. The reason is that it originally referred to the internal version number of the Java libraries, but then was generalized to refer to the entire release. With Java 2, Sun repackaged the Java product as J2SE (Java 2 Platform Standard Edition), and the version numbers began to be applied to that product. Java 2 added support for a number of new features, such as Swing and the Collections Framework, and it enhanced the Java Virtual Machine and various programming tools. Java 2 also contained a few deprecations. The most important affected the Thread class in which the methods suspend( ) , resume( ) , and stop( ) were deprecated. J2SE 1.3 was the first major upgrade to the original Java 2 release. For the most part, it added to existing functionality and “tightened up” the development environment. In general, programs written for version 1.2 and those written for version 1.3 are source-code compatible. Although version 1.3 contained a smaller set of changes than the preceding three major releases, it was nevertheless important. The release of J2SE 1.4 further enhanced Java. This release contained several important upgrades, enhancements, and additions. For example, it added the new keyword assert , chained exceptions, and a channel-based I/O subsystem. It also made changes to the Collections Framework and the networking classes. In addition, numerous small changes were made throughout. Despite the significant number of new features, version 1.4 maintained nearly 100 percent source-code compatibility with prior versions. The next release of Java was J2SE 5, and it was revolutionary. Unlike most of the previous Java upgrades, which offered important, but measured improvements, J2SE 5 fundamentally expanded the scope, power, and range of the language. To grasp the magnitude of the changes that J2SE 5 made to Java, J Preface ava is one of the world’s most important and widely used computer languages. Furthermore, it has held that distinction for many years. Unlike some other computer languages whose influence has waned with the passage of time, Java’s has grown stronger. Java leapt to the forefront of Internet programming with its first release. Each subsequent version has solidified that position. Today, it is still the first and best choice for developing web-based applications. It is also a powerful, general-purpose programming language suitable for a wide variety of purposes. Simply put: much of the modern world runs on Java code. Java really is that important. A key reason for Java’s success is its agility. Since its original 1.0 release, Java has continually adapted to changes in the programming environment and to changes in the way that programmers program. Most importantly, it has not just followed the trends, it has helped create them. Java’s ability to accommodate the fast rate of change in the computing world is a crucial part of why it has been and continues to be so successful. Since this book was first published in 1996, it has gone through several editions, each reflecting the ongoing evolution of Java. This is the eleventh edition, and it has been updated for Java SE 11 (JDK 11). As a result, this edition of the book contains a substantial amount of new material, updates, and changes. Of special interest are the discussions of two key features that have been added to Java since the previous edition of this book. The first is local variable type inference because it streamlines some types of local variable declarations. To support local variable type inference, the context-sensitive, reserved type name var has been added to the language. The second key new Java feature is the reworking of the version number to reflect what is expected to be a faster release cycle, which started with JDK 10. As explained in Chapter 1 , Java feature releases are now anticipated to take place every six months. This is important because it is now possible for new features to be added to Java at a more rapid pace than in the past. Although introduced in the previous edition of this book, there are two recently added Java features that are still having a strong impact on Java programmers. The first is modules, which enable you to specify the relationships and dependencies of the code that comprises an application. The addition of modules by JDK 9 represents one of the most profound changes ever made to the Java language. For example, it resulted in the addition of 10 context-sensitive keywords. Modules also significantly impacted the Java API library because its packages are now organized into modules. Furthermore, to support modules, new tools have been added, existing tools have been updated, and a new file format has been defined. Because of their importance, the entirety of Chapter 16 entirety of Chapter 16 is devoted to modules. The second recently added feature is JShell. JShell is a tool that offers an interactive environment in which it is easy to experiment with code snippets without having to write an entire program. Both beginners and experienced professionals will find it quite useful. An introduction to JShell is found in Appendix B . A Book for All Programmers This book is for all programmers, whether you are a novice or an experienced pro. The beginner will find its carefully paced discussions and many examples especially helpful. Its in-depth coverage of Java’s more advanced features and libraries will appeal to the pro. For both, it offers a lasting resource and handy reference. What’s Inside This book is a comprehensive guide to the Java language, describing its syntax, keywords, and fundamental programming principles. Significant portions of the Java API library are also examined. The book is divided into four parts, each focusing on a different aspect of the Java programming environment. Part I presents an in-depth tutorial of the Java language. It begins with the basics, including such things as data types, operators, control statements, and classes. It then moves on to inheritance, packages, interfaces, exception handling, and multithreading. Next, it describes annotations, enumerations, autoboxing, generics, and lambda expressions. I/O is also introduced. The final chapter in Part I covers modules. Part II examines key aspects of Java’s standard API library. Topics include strings, I/O, networking, the standard utilities, the Collections Framework, the AWT, event handling, imaging, concurrency (including the Fork/Join Framework), regular expressions, and the stream library. Part III offers three chapters that introduce Swing. Part IV contains two chapters that show examples of Java in action. The first discusses Java Beans. The second presents an introduction to servlets. Special Thanks I want to give special thanks to Patrick Naughton, Joe O’Neil, and Danny Coward. Patrick Naughton was one of the creators of the Java language. He also helped write the first edition of this book. For example, among many other contributions, much of the material in Chapters 21 , 23 , and 27 was initially 44 PART 1 Getting Started with Java The first category (the grammar) includes rules like, “The verb agrees with the noun in number and person.” The second category (expressions, sayings, and stuff) includes knowledge like, “Julius Caesar was a famous Roman emperor, so don’t name your son Julius Caesar, unless you want him to get beaten up every day after school.” The Java programming language has all the aspects of a spoken language like English. Java has words, grammar, commonly used names, stylistic idioms, and other such elements. The grammar and the common names The people at Sun Microsystems who created Java thought of Java as having two parts. Just as English has its grammar and commonly used names, the Java programming language has its specification (its grammar) and its application programming interface (its commonly used names). Whenever I write Java pro- grams, I keep two important pieces of documentation — one for each part of the language — on my desk: » The Java Language Specification: This documentation includes rules like this: “Always put an open parenthesis after the word for” and “Use an asterisk to multiply two numbers.” » The application programming interface: Java’s application programming interface (API) contains thousands of names that were added to Java after the language’s grammar was defined. These names range from the commonplace to the exotic. For example, one name — the name JFrame — represents a window on your computer’s screen. A more razzle-dazzle name — pow — helps you raise 5 to the tenth power, or raise whatever to the whatever else power. Other names help you listen for the user’s button clicks, query databases, and do all kinds of useful things. You can download the language specification, the API documents, and all the other Java documentation (or view the documents online) by poking around at http://docs.oracle.com/javase/specs. The first part of Java, the language specification, is relatively small. That doesn’t mean you won’t take plenty of time finding out how to use the rules in the lan- guage specification. Other programming languages, however, have double, triple, or ten times the number of rules. The second part of Java — the API — can be intimidating because it’s so large. The API contains thousands and thousands of names and keeps growing with each new Java language release. Pretty scary, eh? Well, the good news is that you don’t CHAPTER 3 Using the Basic Building Blocks 45 have to memorize anything in the API. Nothing. None of it. You can look up the stuff you need to use in the documentation and ignore the stuff you don’t need. What you use often, you’ll remember. What you don’t use often, you’ll forget (like any other programmer). No one knows all there is to know about the Java API. If you’re a Java programmer who frequently writes programs that open new windows, you know how to use the API JFrame class. If you seldom write programs that open windows, the first few times you need to create a window, you can look up the JFrame class in the API documentation. My guess is that if you prevented a typical Java programmer from looking up anything in the API documentation, the programmer would be able to use less than 2 percent of all the names in the Java API. You may love the For Dummies style, but unfortunately, Java’s official API documentation isn’t written that way. The API documentation is both concise and precise. For some help deciphering the API documentation’s language and style, see this book’s website (www.allmycode.com/JavaForDummies). In a way, nothing about the Java API is special. Whenever you write a Java program — even the smallest, simplest Java program — you create a class that’s on par with any of the classes defined in the official Java API. The API is just a set of classes and other names that were created by ordinary programmers who hap- pen to participate in the official Java Community Process (JCP) and in the OpenJDK Project. Unlike the names you create, the names in the API are distributed with every version of Java. (I’m assuming that you, the reader, are not a participant in the Java Community Process or the OpenJDK Project. But, with a fine book like Java For Dummies, 7th Edition, one never knows.) For Dummies, 7th Edition, one never knows.) If you’re interested in the JCP’s activities, visit www.jcp.org. If you’re interested in the OpenJDK Project, visit http://openjdk.java.net. The folks at the JCP don’t keep the Java programs in the official Java API a secret. If you want, you can look at all these programs. When you install Java on your computer, the installation puts a file named src.zip on your hard drive. You can src.zip on your hard drive. You can open src.zip with your favorite unzipping program. There, before your eyes, is all the Java API code. The words in a Java program A hard-core Javateer will say that the Java programming language has two kinds of words: keywords and identifiers. This is true. But the bare truth, without any other explanation, is sometimes misleading. So I recommend dressing up the truth a bit and thinking in terms of three kinds of words: keywords, identifiers
